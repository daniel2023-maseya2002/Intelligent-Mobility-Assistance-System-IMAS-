<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IMAS - Simulateur de Circulation 3D Kinshasa</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            cursor: none;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 16px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        #ui.minimized {
            transform: translateX(-80%);
            opacity: 0.7;
        }

        #ui h2 {
            margin-bottom: 10px;
            color: #00d4ff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        #ui div {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #ui span {
            color: #00ff88;
            font-weight: bold;
        }

        #toggleUI {
            position: absolute;
            top: 20px;
            left: 300px;
            z-index: 1001;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        #toggleUI:hover {
            background: rgba(0, 212, 255, 0.8);
            transform: scale(1.05);
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        #controls h3 {
            margin-bottom: 10px;
            color: #ffaa00;
            text-shadow: 0 0 10px rgba(255, 170, 0, 0.5);
        }

        #controls div {
            margin: 5px 0;
            padding: 2px 0;
        }

        #controlCenter {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        #controlCenter button {
            background: linear-gradient(45deg, #FF6B6B, #FF8E8E);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
            transition: all 0.3s ease;
            margin-bottom: 10px;
            display: block;
            width: 100%;
        }

        #controlCenter button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        #zoomControls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }

        #zoomControls button {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 10px 15px;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s ease;
            display: block;
        }

        #zoomControls button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        #minimap {
            position: absolute;
            top: 20px;
            right: 220px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00d4ff;
            border-radius: 15px;
            z-index: 1000;
            overflow: hidden;
        }

        .speed-meter {
            position: absolute;
            bottom: 200px;
            right: 20px;
            width: 160px;
            height: 160px;
            background: radial-gradient(circle, #000 30%, #1a1a2e 70%, #00d4ff 100%);
            border-radius: 50%;
            border: 4px solid #00d4ff;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 28px;
            font-weight: bold;
            z-index: 1000;
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.5);
        }

        .speed-meter::before {
            content: '';
            position: absolute;
            width: 140px;
            height: 140px;
            border-radius: 50%;
            border: 2px solid rgba(0, 212, 255, 0.3);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.5; }
            100% { transform: scale(1); opacity: 1; }
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            margin: 5% auto;
            padding: 30px;
            border-radius: 20px;
            width: 90%;
            max-width: 1200px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }

        .modal-header h2 {
            color: #00d4ff;
            font-size: 28px;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .close {
            color: #ff6b6b;
            float: right;
            font-size: 35px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close:hover {
            color: #ff4444;
        }

        .bus-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .bus-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .bus-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.3);
        }

        .bus-card h3 {
            color: #00d4ff;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .bus-info {
            color: #ffffff;
            margin-bottom: 15px;
        }

        .bus-info div {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
        }

        .bus-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            font-size: 14px;
            flex: 1;
        }

        .btn-primary {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #FF9800, #F57C00);
            color: white;
            box-shadow: 0 4px 15px rgba(255, 152, 0, 0.3);
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 152, 0, 0.4);
        }

        .btn-danger {
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.3);
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(244, 67, 54, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .route-info {
            position: absolute;
            top: 300px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            z-index: 1000;
            max-width: 250px;
            display: none;
        }

        .route-info h4 {
            color: #00d4ff;
            margin-bottom: 10px;
        }

        .status-indicators {
            position: absolute;
            bottom: 20px;
            right: 200px;
            z-index: 1000;
        }

        .status-indicator {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            margin: 5px 0;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .status-indicator.active {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            z-index: 3000;
            display: none;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .accident-alert {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #ff0000, #ff4444);
            color: white;
            padding: 30px;
            border-radius: 15px;
            font-size: 20px;
            z-index: 2000;
            display: none;
            text-align: center;
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.8);
            animation: shake 0.5s ease-in-out infinite;
        }

        @keyframes shake {
            0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
            25% { transform: translate(-50%, -50%) rotate(1deg); }
            75% { transform: translate(-50%, -50%) rotate(-1deg); }
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00d4ff;
            font-size: 28px;
            z-index: 1000;
            text-align: center;
        }

        .loading::after {
            content: '';
            display: block;
            width: 40px;
            height: 40px;
            margin: 20px auto;
            border: 4px solid rgba(0, 212, 255, 0.3);
            border-top: 4px solid #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .traffic-light {
            position: absolute;
            background: #333;
            border-radius: 8px;
            width: 25px;
            height: 70px;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            align-items: center;
            padding: 5px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        .light {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #555;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .light.red {
            background: #ff0000;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
        }
        .light.yellow {
            background: #ffff00;
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.8);
        }
        .light.green {
            background: #00ff00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.8);
        }

        .bus-status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .bus-status.en-service {
            background: #4CAF50;
            color: white;
        }

        .bus-status.en-panne {
            background: #f44336;
            color: white;
        }

        .bus-status.arrete {
            background: #ff9800;
            color: white;
        }

        .bus-status.arrive {
            background: #2196F3;
            color: white;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        .map-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 400px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00d4ff;
            border-radius: 15px;
            display: none;
            z-index: 1500;
        }

        .map-header {
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            color: white;
            padding: 15px;
            border-radius: 13px 13px 0 0;
            text-align: center;
            font-weight: bold;
        }

        .map-content {
            padding: 20px;
            color: white;
            height: calc(100% - 60px);
            overflow-y: auto;
        }

        .route-point {
            margin: 10px 0;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border-left: 4px solid #00d4ff;
        }

        .route-point.current {
            background: rgba(0, 212, 255, 0.2);
        }

        .route-point.destination {
            border-left-color: #4CAF50;
        }
    </style>
</head>
<body>
<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div class="loading" id="loading">Chargement du simulateur IMAS...</div>

    <button id="toggleUI">👁️ Masquer UI</button>

    <div id="ui">
        <h2>🚌 IMAS - Centre de Contrôle</h2>
        <div>Vue: <span id="cameraMode">Troisième Personne</span></div>
        <div>Vitesse: <span id="speed">0</span> km/h</div>
        <div>Accidents: <span id="accidents">0</span></div>
        <div>Bus Actifs: <span id="vehicleCount">0</span></div>
        <div>FPS: <span id="fps">60</span></div>
        <div>Simulation: <span id="simulationMode">Manuelle</span></div>
        <div>Bus Sélectionné: <span id="selectedBus">Aucun</span></div>
    </div>

    <div id="controls">
        <h3>Contrôles:</h3>
        <div>🎮 WASD/Flèches: Conduire</div>
        <div>📷 C: Changer de vue</div>
        <div>🔄 R: Redémarrer</div>
        <div>⏸️ P: Pause</div>
        <div>🛑 Espace: Frein à main</div>
        <div>🚌 M: Gestion des Bus</div>
        <div>🤖 A: Simulation Auto</div>
        <div>🗺️ Tab: Carte de Route</div>
    </div>

    <div id="controlCenter">
        <button onclick="openBusModal()">🚌 Gestion des Bus</button>
        <button onclick="toggleAutoSimulation()">🤖 Simulation Auto</button>
        <button onclick="openControlCenter()">🏢 Centre de Contrôle</button>
        <button onclick="toggleMap()">🗺️ Carte</button>
    </div>

    <div id="zoomControls">
        <button onclick="zoomIn()">+</button>
        <button onclick="zoomOut()">-</button>
        <button onclick="resetCamera()">🏠</button>
    </div>

    <div id="minimap"></div>

    <div class="speed-meter">
        <div id="speedDisplay">0</div>
    </div>

    <div class="route-info" id="routeInfo">
        <h4>Informations de Route</h4>
        <div id="routeDetails">
            <div>Route: <span id="currentRoute">Sélectionnez un bus</span></div>
            <div>Destination: <span id="destination">-</span></div>
            <div>Distance: <span id="distance">0 km</span></div>
            <div>Temps Estimé: <span id="estimatedTime">0 min</span></div>
            <div>Progression: <span id="routeProgress">0%</span></div>
        </div>
    </div>

    <div class="status-indicators">
        <div class="status-indicator" id="connectionStatus">🌐 Connexion Backend</div>
        <div class="status-indicator" id="databaseStatus">💾 Base de Données</div>
    </div>

    <div class="accident-alert" id="accidentAlert">
        ⚠️ ACCIDENT DÉTECTÉ! ⚠️<br>
        Sauvegarde automatique en cours...
    </div>

    <div class="notification" id="notification">
        <div id="notificationText"></div>
    </div>

    <div class="map-container" id="mapContainer">
        <div class="map-header">
            <span>🗺️ Carte de Route - Kinshasa</span>
            <button onclick="toggleMap()" style="float: right; background: none; border: none; color: white; font-size: 20px; cursor: pointer;">×</button>
        </div>
        <div class="map-content" id="mapContent">
            <div class="route-point">📍 Chargement des routes...</div>
        </div>
    </div>

    <!-- Modal de gestion des bus -->
    <div id="busModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>🚌 Gestion des Bus - Kinshasa</h2>
                <span class="close" onclick="closeBusModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div id="busLoadingMessage">
                    <div class="loading-spinner"></div>
                    Chargement des bus depuis la base de données...
                </div>
                <div id="busGrid" class="bus-grid"></div>
            </div>
        </div>
    </div>

    <!-- Modal du centre de contrôle -->
    <div id="controlModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>🏢 Centre de Contrôle IMAS</h2>
                <span class="close" onclick="closeControlModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                    <div class="bus-card">
                        <h3>📊 Statistiques</h3>
                        <div class="bus-info">
                            <div>Total Bus: <span id="totalBuses">0</span></div>
                            <div>En Service: <span id="busesInService">0</span></div>
                            <div>En Panne: <span id="busesOutOfService">0</span></div>
                            <div>Incidents: <span id="totalIncidents">0</span></div>
                        </div>
                    </div>
                    <div class="bus-card">
                        <h3>🚨 Alertes</h3>
                        <div id="alertsList" class="bus-info">
                            <div>Aucune alerte active</div>
                        </div>
                    </div>
                    <div class="bus-card">
                        <h3>⚙️ Paramètres</h3>
                        <div class="bus-actions">
                            <button class="btn btn-primary" onclick="refreshBusData()">Actualiser</button>
                            <button class="btn btn-secondary" onclick="exportData()">Exporter</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // Configuration du jeu
    const CONFIG = {
        WORLD_SIZE: 2000,
        ROAD_WIDTH: 40,
        VEHICLE_COUNT: 20,
        TRAFFIC_LIGHT_INTERVAL: 10000,
        ACCIDENT_PROBABILITY: 0.001,
        PHYSICS_TIMESTEP: 1/60,
        BACKEND_URL: 'http://localhost:8080/api',
        KINSHASA_ROUTES: [
            { name: 'Gombe-Kintambo', start: {x: 0, z: 0}, end: {x: 200, z: 300}, color: '#FF0000' },
            { name: 'Bandalungwa-Lemba', start: {x: -200, z: 0}, end: {x: 200, z: 200}, color: '#00FF00' },
            { name: 'Matongé-Ngaliema', start: {x: -300, z: -200}, end: {x: 300, z: 0}, color: '#0000FF' },
            { name: 'Kalamu-Makala', start: {x: 0, z: -300}, end: {x: -200, z: 200}, color: '#FFFF00' },
            { name: 'Lingwala-Barumbu', start: {x: 300, z: 0}, end: {x: -300, z: 300}, color: '#FF00FF' }
        ]
    };

    // Variables globales
    let scene, camera, renderer, playerCar, vehicles = [], buildings = [], trafficLights = [];
    let cameraMode = 0, zoomLevel = 1;
    let keys = {}, gameState = {
        speed: 0,
        accidents: 0,
        isPaused: false,
        isAutoSimulation: false,
        selectedBus: null,
        busProgress: {},
        routes: [],
        activeBuses: [],
        uiMinimized: false
    };
    let roads = [], intersections = [];
    let fpsCounter = 0, lastTime = 0;
    let busDatabase = [];
    let simulationBuses = [];
    let routeDatabase = [];

    // Système de notification
    function showNotification(message, type = 'success') {
        const notification = document.getElementById('notification');
        const notificationText = document.getElementById('notificationText');

        notificationText.textContent = message;

        if (type === 'error') {
            notification.style.background = 'linear-gradient(45deg, #f44336, #d32f2f)';
        } else if (type === 'warning') {
            notification.style.background = 'linear-gradient(45deg, #FF9800, #F57C00)';
        } else {
            notification.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
        }

        notification.style.display = 'block';

        setTimeout(() => {
            notification.style.display = 'none';
        }, 3000);
    }

    // Communication avec le backend
    class BackendAPI {
        static async loadBuses() {
            try {
                console.log('Chargement des bus depuis la base de données...');
                const response = await fetch(`${CONFIG.BACKEND_URL}/buses`).catch(() => {
                    throw new Error('Impossible de se connecter au backend');
                });

                if (response.ok) {
                    const buses = await response.json();
                    console.log('Bus chargés:', buses.length);
                    busDatabase = buses;
                    updateConnectionStatus('database', true);
                    return buses;
                } else {
                    throw new Error('Erreur lors du chargement des bus');
                }
            } catch (error) {
                console.error('Erreur backend:', error);
                updateConnectionStatus('database', false);
                showNotification('Erreur lors du chargement des bus. Utilisation des données par défaut.', 'warning');
                return this.getDefaultBuses();
            }
        }

        static async loadRoutes() {
            try {
                console.log('Chargement des routes depuis la base de données...');
                const response = await fetch(`${CONFIG.BACKEND_URL}/routes`).catch(() => {
                    throw new Error('Impossible de se connecter au backend');
                });

                if (response.ok) {
                    const routes = await response.json();
                    console.log('Routes chargées:', routes.length);
                    routeDatabase = routes;
                    return routes;
                } else {
                    throw new Error('Erreur lors du chargement des routes');
                }
            } catch (error) {
                console.error('Erreur backend routes:', error);
                return this.getDefaultRoutes();
            }
        }

        static getDefaultBuses() {
            return [
                {
                    id: 1,
                    name: 'Bus KIN-001',
                    busLine: 'Ligne 1',
                    capacity: 45,
                    startLat: 0,
                    startLng: 0,
                    endLat: 200,
                    endLng: 300,
                    currentLat: 0,
                    currentLng: 0,
                    stopped: false,
                    hasAccident: false,
                    driver: { firstName: 'Jean', lastName: 'Mukendi' },
                    route: { routeName: 'Gombe-Kintambo', color: '#FF0000' }
                },
                {
                    id: 2,
                    name: 'Bus KIN-002',
                    busLine: 'Ligne 2',
                    capacity: 50,
                    startLat: -200,
                    startLng: 0,
                    endLat: 200,
                    endLng: 200,
                    currentLat: -200,
                    currentLng: 0,
                    stopped: false,
                    hasAccident: false,
                    driver: { firstName: 'Marie', lastName: 'Kabila' },
                    route: { routeName: 'Bandalungwa-Lemba', color: '#00FF00' }
                },
                {
                    id: 3,
                    name: 'Bus KIN-003',
                    busLine: 'Ligne 3',
                    capacity: 40,
                    startLat: -300,
                    startLng: -200,
                    endLat: 300,
                    endLng: 0,
                    currentLat: -300,
                    currentLng: -200,
                    stopped: true,
                    hasAccident: false,
                    driver: { firstName: 'Paul', lastName: 'Tshisekedi' },
                    route: { routeName: 'Matongé-Ngaliema', color: '#0000FF' }
                }
            ];
        }

        static getDefaultRoutes() {
            return [
                {
                    id: 1,
                    routeName: 'Gombe-Kintambo',
                    routeCode: 'GK001',
                    description: 'Route du centre-ville vers Kintambo',
                    totalDistance: 12.5,
                    estimatedDuration: 35,
                    color: '#FF0000',
                    stops: [
                        { name: 'Gombe Centre', lat: 0, lng: 0 },
                        { name: 'Marché Central', lat: 50, lng: 75 },
                        { name: 'Pont Kasavubu', lat: 100, lng: 150 },
                        { name: 'Kintambo', lat: 200, lng: 300 }
                    ]
                },
                {
                    id: 2,
                    routeName: 'Bandalungwa-Lemba',
                    routeCode: 'BL002',
                    description: 'Route de Bandalungwa vers Lemba',
                    totalDistance: 15.2,
                    estimatedDuration: 40,
                    color: '#00FF00',
                    stops: [
                        { name: 'Bandalungwa', lat: -200, lng: 0 },
                        { name: 'Matonge', lat: -100, lng: 50 },
                        { name: 'Rond-point Victoire', lat: 0, lng: 100 },
                        { name: 'Lemba', lat: 200, lng: 200 }
                    ]
                }
            ];
        }

        static async saveIncident(incidentData) {
            try {
                console.log('Sauvegarde de l\'incident:', incidentData);
                const response = await fetch(`${CONFIG.BACKEND_URL}/incidents`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(incidentData)
                }).catch(() => {
                    console.log('Simulation de sauvegarde d\'incident');
                    return { ok: true, json: () => Promise.resolve({ id: Date.now() }) };
                });

                if (response.ok) {
                    const result = await response.json();
                    console.log('Incident sauvegardé:', result);
                    showNotification('Incident sauvegardé avec succès', 'success');
                    updateConnectionStatus('connection', true);
                    return result;
                } else {
                    throw new Error('Erreur lors de la sauvegarde');
                }
            } catch (error) {
                console.error('Erreur sauvegarde incident:', error);
                updateConnectionStatus('connection', false);
                showNotification('Erreur lors de la sauvegarde de l\'incident', 'error');
                return null;
            }
        }

        static async updateBusStatus(busId, status, location = null) {
            try {
                const updateData = {
                    status: status,
                    currentLat: location ? location.x : null,
                    currentLng: location ? location.z : null
                };

                console.log('Mise à jour du bus:', busId, updateData);
                const response = await fetch(`${CONFIG.BACKEND_URL}/buses/${busId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(updateData)
                }).catch(() => {
                    console.log('Simulation de mise à jour du bus');
                    return { ok: true, json: () => Promise.resolve({ success: true }) };
                });

                if (response.ok) {
                    const result = await response.json();
                    console.log('Statut bus mis à jour:', result);
                    return result;
                } else {
                    throw new Error('Erreur lors de la mise à jour');
                }
            } catch (error) {
                console.error('Erreur mise à jour bus:', error);
                return null;
            }
        }
    }

    // Gestion des modals
    function openBusModal() {
        document.getElementById('busModal').style.display = 'block';
        loadBusData();
    }

    function closeBusModal() {
        document.getElementById('busModal').style.display = 'none';
    }

    function openControlCenter() {
        document.getElementById('controlModal').style.display = 'block';
        updateControlCenterData();
    }

    function closeControlModal() {
        document.getElementById('controlModal').style.display = 'none';
    }

    function toggleMap() {
        const mapContainer = document.getElementById('mapContainer');
        if (mapContainer.style.display === 'none' || mapContainer.style.display === '') {
            mapContainer.style.display = 'block';
            loadRouteMap();
        } else {
            mapContainer.style.display = 'none';
        }
    }

    function loadRouteMap() {
        const mapContent = document.getElementById('mapContent');
        mapContent.innerHTML = '<div class="route-point">📍 Chargement des routes...</div>';

        setTimeout(() => {
            const routes = routeDatabase.length > 0 ? routeDatabase : BackendAPI.getDefaultRoutes();
            let mapHTML = '';

            routes.forEach(route => {
                mapHTML += `
                    <div class="route-point" style="border-left-color: ${route.color}">
                        <strong>${route.routeName}</strong><br>
                        <small>${route.description}</small><br>
                        <small>Distance: ${route.totalDistance} km - Durée: ${route.estimatedDuration} min</small>
                    </div>
                `;
            });

            mapContent.innerHTML = mapHTML;
        }, 500);
    }

    // Chargement des données des bus
    async function loadBusData() {
        const loadingMessage = document.getElementById('busLoadingMessage');
        const busGrid = document.getElementById('busGrid');

        loadingMessage.style.display = 'block';
        busGrid.innerHTML = '';

        try {
            const buses = await BackendAPI.loadBuses();
            loadingMessage.style.display = 'none';

            if (buses && buses.length > 0) {
                displayBuses(buses);
            } else {
                busGrid.innerHTML = '<div style="color: white; text-align: center; padding: 20px;">Aucun bus trouvé dans la base de données</div>';
            }
        } catch (error) {
            console.error('Erreur lors du chargement des bus:', error);
            loadingMessage.style.display = 'none';
            busGrid.innerHTML = '<div style="color: #ff6b6b; text-align: center; padding: 20px;">Erreur lors du chargement des bus</div>';
        }
    }

    // Affichage des bus
    function displayBuses(buses) {
        const busGrid = document.getElementById('busGrid');
        busGrid.innerHTML = '';

        buses.forEach(bus => {
            const busCard = document.createElement('div');
            busCard.className = 'bus-card';

            const status = getBusStatus(bus);
            const statusClass = getStatusClass(status);
            const progress = gameState.busProgress[bus.id] || 0;
            const driverName = bus.driver ? `${bus.driver.firstName} ${bus.driver.lastName}` : 'Non assigné';
            const routeName = bus.route ? bus.route.routeName : 'Route non définie';

            busCard.innerHTML = `
                <h3>🚌 ${bus.name}</h3>
                <div class="bus-info">
                    <div>Route: <span>${routeName}</span></div>
                    <div>Ligne: <span>${bus.busLine}</span></div>
                    <div>Conducteur: <span>${driverName}</span></div>
                    <div>Capacité: <span>${bus.capacity} places</span></div>
                    <div>Statut: <span class="bus-status ${statusClass}">${status}</span></div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: ${progress}%"></div>
                </div>
                <div style="text-align: center; margin: 10px 0; color: #00d4ff;">
                    Progression: ${Math.round(progress)}%
                </div>
                <div class="bus-actions">
                    <button class="btn btn-primary" onclick="selectBus(${bus.id})" ${status === 'En Panne' ? 'disabled' : ''}>
                        🎮 Conduire
                    </button>
                    <button class="btn btn-secondary" onclick="startAutoSimulation(${bus.id})" ${status === 'En Panne' ? 'disabled' : ''}>
                        🤖 Auto
                    </button>
                    <button class="btn btn-danger" onclick="stopBus(${bus.id})">
                        🛑 Arrêter
                    </button>
                </div>
            `;

            busGrid.appendChild(busCard);
        });
    }

    function getBusStatus(bus) {
        if (bus.hasAccident) return 'En Panne';
        if (bus.stopped) return 'Arrêté';
        return 'En Service';
    }

    function getStatusClass(status) {
        switch(status) {
            case 'En Service': return 'en-service';
            case 'En Panne': return 'en-panne';
            case 'Arrêté': return 'arrete';
            default: return 'arrete';
        }
    }

    // Sélection d'un bus
    function selectBus(busId) {
        const bus = busDatabase.find(b => b.id === busId);
        if (bus && !bus.hasAccident) {
            gameState.selectedBus = bus;

            // Créer ou mettre à jour le véhicule du joueur
            if (playerCar) {
                scene.remove(playerCar.mesh);
                vehicles = vehicles.filter(v => v !== playerCar);
            }

            playerCar = new Vehicle(bus.currentLat || bus.startLat, bus.currentLng || bus.startLng, 'city_bus');
            playerCar.isPlayer = true;
            playerCar.busData = bus;
            playerCar.destination = { x: bus.endLat, z: bus.endLng };

            // Couleur spéciale pour le bus sélectionné
            if (playerCar.mesh.children[0]) {
                playerCar.mesh.children[0].material.color.setHex(0x00FF00);
            }

            vehicles.push(playerCar);

            // Mettre à jour les informations de route
            updateRouteInfo();
            document.getElementById('selectedBus').textContent = bus.name;

            showNotification(`Bus ${bus.name} sélectionné`, 'success');
            closeBusModal();
        }
    }

    // Démarrage de la simulation automatique
    function startAutoSimulation(busId) {
        const bus = busDatabase.find(b => b.id === busId);
        if (bus && !bus.hasAccident) {
            // Créer un véhicule automatique
            const autoBus = new Vehicle(bus.currentLat || bus.startLat, bus.currentLng || bus.startLng, 'city_bus');
            autoBus.isPlayer = false;
            autoBus.busData = bus;
            autoBus.destination = { x: bus.endLat, z: bus.endLng };
            autoBus.isAutoSimulation = true;
            autoBus.targetSpeed = 25;

            // Couleur spéciale pour les bus automatiques
            if (autoBus.mesh.children[0]) {
                autoBus.mesh.children[0].material.color.setHex(0xFF8800);
            }

            vehicles.push(autoBus);
            simulationBuses.push(autoBus);

            gameState.busProgress[busId] = 0;

            showNotification(`Simulation automatique démarrée pour ${bus.name}`, 'success');
            closeBusModal();
        }
    }

    // Arrêt d'un bus
    function stopBus(busId) {
        const bus = busDatabase.find(b => b.id === busId);
        if (bus) {
            // Arrêter la simulation automatique
            simulationBuses = simulationBuses.filter(simBus => {
                if (simBus.busData.id === busId) {
                    scene.remove(simBus.mesh);
                    vehicles = vehicles.filter(v => v !== simBus);
                    return false;
                }
                return true;
            });

            // Arrêter le bus manuel
            if (playerCar && playerCar.busData && playerCar.busData.id === busId) {
                playerCar.speed = 0;
                gameState.selectedBus = null;
                document.getElementById('selectedBus').textContent = 'Aucun';
            }

            gameState.busProgress[busId] = 0;

            showNotification(`Bus ${bus.name} arrêté`, 'warning');
            BackendAPI.updateBusStatus(busId, 'ARRETE');
        }
    }

    // Mise à jour des informations de route
    function updateRouteInfo() {
        const routeInfo = document.getElementById('routeInfo');
        const currentRoute = document.getElementById('currentRoute');
        const destination = document.getElementById('destination');
        const distance = document.getElementById('distance');
        const estimatedTime = document.getElementById('estimatedTime');
        const routeProgress = document.getElementById('routeProgress');

        if (gameState.selectedBus && playerCar) {
            const bus = gameState.selectedBus;
            const dist = Math.sqrt(
                Math.pow(bus.endLat - playerCar.position.x, 2) +
                Math.pow(bus.endLng - playerCar.position.z, 2)
            );

            const progress = gameState.busProgress[bus.id] || 0;
            const routeName = bus.route ? bus.route.routeName : 'Route inconnue';

            currentRoute.textContent = routeName;
            destination.textContent = `(${bus.endLat}, ${bus.endLng})`;
            distance.textContent = `${(dist / 100).toFixed(1)} km`;
            estimatedTime.textContent = `${Math.round(dist / 50)} min`;
            routeProgress.textContent = `${Math.round(progress)}%`;

            routeInfo.style.display = 'block';
        } else {
            routeInfo.style.display = 'none';
        }
    }

    // Mise à jour des données du centre de contrôle
    function updateControlCenterData() {
        const totalBuses = busDatabase.length;
        const busesInService = busDatabase.filter(b => !b.hasAccident && !b.stopped).length;
        const busesOutOfService = busDatabase.filter(b => b.hasAccident || b.stopped).length;

        document.getElementById('totalBuses').textContent = totalBuses;
        document.getElementById('busesInService').textContent = busesInService;
        document.getElementById('busesOutOfService').textContent = busesOutOfService;
        document.getElementById('totalIncidents').textContent = gameState.accidents;
    }

    // Mise à jour du statut de connexion
    function updateConnectionStatus(type, isConnected) {
        const statusElement = document.getElementById(type === 'database' ? 'databaseStatus' : 'connectionStatus');
        if (isConnected) {
            statusElement.classList.add('active');
            statusElement.textContent = type === 'database' ? '💾 Base de Données ✓' : '🌐 Connexion Backend ✓';
        } else {
            statusElement.classList.remove('active');
            statusElement.textContent = type === 'database' ? '💾 Base de Données ✗' : '🌐 Connexion Backend ✗';
        }
    }

    // Contrôles de zoom
    function zoomIn() {
        zoomLevel = Math.min(zoomLevel * 1.2, 3);
        updateCameraZoom();
    }

    function zoomOut() {
        zoomLevel = Math.max(zoomLevel / 1.2, 0.3);
        updateCameraZoom();
    }

    function resetCamera() {
        zoomLevel = 1;
        cameraMode = 0;
        updateCameraZoom();
        document.getElementById('cameraMode').textContent = 'Troisième Personne';
    }

    function updateCameraZoom() {
        if (camera) {
            camera.zoom = zoomLevel;
            camera.updateProjectionMatrix();
        }
    }

    // Basculer la simulation automatique
    function toggleAutoSimulation() {
        gameState.isAutoSimulation = !gameState.isAutoSimulation;

        if (gameState.isAutoSimulation) {
            busDatabase.forEach(bus => {
                if (!bus.hasAccident && !bus.stopped && !simulationBuses.find(sb => sb.busData.id === bus.id)) {
                    startAutoSimulation(bus.id);
                }
            });

            document.getElementById('simulationMode').textContent = 'Automatique';
            showNotification('Simulation automatique activée', 'success');
        } else {
            simulationBuses.forEach(simBus => {
                scene.remove(simBus.mesh);
                vehicles = vehicles.filter(v => v !== simBus);
            });
            simulationBuses = [];

            document.getElementById('simulationMode').textContent = 'Manuelle';
            showNotification('Simulation automatique désactivée', 'warning');
        }
    }

    // Basculer l'UI
    function toggleUI() {
        const ui = document.getElementById('ui');
        const toggleBtn = document.getElementById('toggleUI');

        gameState.uiMinimized = !gameState.uiMinimized;

        if (gameState.uiMinimized) {
            ui.classList.add('minimized');
            toggleBtn.textContent = '👁️ Afficher UI';
        } else {
            ui.classList.remove('minimized');
            toggleBtn.textContent = '👁️ Masquer UI';
        }
    }

    // Actualiser les données des bus
    function refreshBusData() {
        showNotification('Actualisation des données...', 'info');
        loadBusData();
    }

    // Exporter les données
    function exportData() {
        const data = {
            buses: busDatabase,
            accidents: gameState.accidents,
            routes: routeDatabase,
            timestamp: new Date().toISOString()
        };

        const dataStr = JSON.stringify(data, null, 2);
        const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);

        const exportFileDefaultName = `imas_data_${new Date().toISOString().split('T')[0]}.json`;

        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();

        showNotification('Données exportées avec succès', 'success');
    }

    // Classe pour les véhicules avec designs améliorés
    class Vehicle {
        constructor(x, z, type = 'sports_car') {
            this.type = type;
            this.position = { x, z };
            this.rotation = 0;
            this.speed = 0;
            this.maxSpeed = type === 'city_bus' ? 35 : 60;
            this.acceleration = type === 'city_bus' ? 0.8 : 1.2;
            this.isPlayer = false;
            this.crashed = false;
            this.targetSpeed = Math.random() * this.maxSpeed;
            this.lane = Math.floor(Math.random() * 3);
            this.direction = Math.random() > 0.5 ? 1 : -1;
            this.busData = null;
            this.destination = null;
            this.isAutoSimulation = false;
            this.distanceTraveled = 0;
            this.totalDistance = 0;

            this.createMesh();
            this.setupAI();
        }

        createMesh() {
            const group = new THREE.Group();

            if (this.type === 'sports_car') {
                this.createSportsCar(group);
            } else if (this.type === 'city_bus') {
                this.createCityBus(group);
            }

            this.mesh = group;
            this.mesh.position.set(this.position.x, 0, this.position.z);
            this.mesh.castShadow = true;
            this.mesh.receiveShadow = true;
            scene.add(this.mesh);
        }

        createSportsCar(group) {
            const colors = [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF, 0x00FFFF, 0xFFA500, 0x800080];
            const bodyColor = colors[Math.floor(Math.random() * colors.length)];

            const bodyGeometry = new THREE.BoxGeometry(4.5, 2, 9);
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: bodyColor,
                shininess: 100,
                specular: 0x222222
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1.5;
            group.add(body);

            const roofGeometry = new THREE.BoxGeometry(3.5, 1.5, 5);
            const roofMaterial = new THREE.MeshPhongMaterial({
                color: bodyColor,
                shininess: 100
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 3;
            roof.position.z = -0.5;
            group.add(roof);

            const hoodGeometry = new THREE.BoxGeometry(4, 1.8, 3);
            const hood = new THREE.Mesh(hoodGeometry, bodyMaterial);
            hood.position.y = 1.8;
            hood.position.z = 3;
            hood.rotation.x = -0.1;
            group.add(hood);

            const spoilerGeometry = new THREE.BoxGeometry(3, 0.3, 0.8);
            const spoilerMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const spoiler = new THREE.Mesh(spoilerGeometry, spoilerMaterial);
            spoiler.position.y = 3.5;
            spoiler.position.z = -4;
            group.add(spoiler);

            const wheelGeometry = new THREE.CylinderGeometry(1.2, 1.2, 0.8, 12);
            const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
            const rimMaterial = new THREE.MeshPhongMaterial({ color: 0xCCCCCC });

            const wheelPositions = [
                [-2, 0, 3.5], [2, 0, 3.5], [-2, 0, -3.5], [2, 0, -3.5]
            ];

            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos[0], pos[1], pos[2]);
                wheel.rotation.z = Math.PI / 2;
                group.add(wheel);

                const rimGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.9, 8);
                const rim = new THREE.Mesh(rimGeometry, rimMaterial);
                rim.position.set(pos[0], pos[1], pos[2]);
                rim.rotation.z = Math.PI / 2;
                group.add(rim);
            });

            const windowGeometry = new THREE.BoxGeometry(3.2, 1.2, 4.5);
            const windowMaterial = new THREE.MeshPhongMaterial({
                color: 0x001133,
                transparent: true,
                opacity: 0.8,
                shininess: 200
            });
            const windows = new THREE.Mesh(windowGeometry, windowMaterial);
            windows.position.y = 3;
            windows.position.z = -0.5;
            group.add(windows);

            const headlightGeometry = new THREE.SphereGeometry(0.4, 12, 8);
            const headlightMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFFFFF,
                emissive: 0x444444
            });

            const headlightPositions = [[-1.5, 1.5, 4.2], [1.5, 1.5, 4.2]];
            headlightPositions.forEach(pos => {
                const headlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
                headlight.position.set(pos[0], pos[1], pos[2]);
                group.add(headlight);
            });

            const taillightGeometry = new THREE.SphereGeometry(0.3, 8, 6);
            const taillightMaterial = new THREE.MeshPhongMaterial({
                color: 0xFF0000,
                emissive: 0x220000
            });

            const taillightPositions = [[-1.5, 1.5, -4.2], [1.5, 1.5, -4.2]];
            taillightPositions.forEach(pos => {
                const taillight = new THREE.Mesh(taillightGeometry, taillightMaterial);
                taillight.position.set(pos[0], pos[1], pos[2]);
                group.add(taillight);
            });

            const grilleGeometry = new THREE.BoxGeometry(3, 0.8, 0.2);
            const grilleMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const grille = new THREE.Mesh(grilleGeometry, grilleMaterial);
            grille.position.y = 1.2;
            grille.position.z = 4.4;
            group.add(grille);
        }

        createCityBus(group) {
            // Corps principal du bus moderne - Design réaliste
            const bodyGeometry = new THREE.BoxGeometry(11, 8, 26);
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: 0xDD0000,
                shininess: 80
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 4;
            group.add(body);

            // Bande décorative blanche
            const stripeGeometry = new THREE.BoxGeometry(11.2, 2, 26.2);
            const stripeMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
            const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
            stripe.position.y = 2;
            group.add(stripe);

            // Toit moderne
            const roofGeometry = new THREE.BoxGeometry(11.5, 0.8, 26.8);
            const roofMaterial = new THREE.MeshPhongMaterial({ color: 0xCCCCCC });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 8.5;
            group.add(roof);

            // Pare-choc avant
            const frontBumperGeometry = new THREE.BoxGeometry(11.5, 2, 1.5);
            const bumperMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
            const frontBumper = new THREE.Mesh(frontBumperGeometry, bumperMaterial);
            frontBumper.position.y = 2;
            frontBumper.position.z = 13.5;
            group.add(frontBumper);

            // Pare-choc arrière
            const rearBumper = new THREE.Mesh(frontBumperGeometry, bumperMaterial);
            rearBumper.position.y = 2;
            rearBumper.position.z = -13.5;
            group.add(rearBumper);

            // Roues de bus plus réalistes
            const wheelGeometry = new THREE.CylinderGeometry(1.8, 1.8, 1.2, 16);
            const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x1a1a1a });
            const rimGeometry = new THREE.CylinderGeometry(1.4, 1.4, 1.3, 16);
            const rimMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });

            const wheelPositions = [
                [-4.5, 0, 10], [4.5, 0, 10], [-4.5, 0, -10], [4.5, 0, -10]
            ];

            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos[0], pos[1], pos[2]);
                wheel.rotation.z = Math.PI / 2;
                group.add(wheel);

                const rim = new THREE.Mesh(rimGeometry, rimMaterial);
                rim.position.set(pos[0], pos[1], pos[2]);
                rim.rotation.z = Math.PI / 2;
                group.add(rim);
            });

            // Fenêtres du bus - Plus réalistes
            const windowPositions = [
                // Côté gauche
                [-5.8, 5, 8], [-5.8, 5, 4], [-5.8, 5, 0], [-5.8, 5, -4], [-5.8, 5, -8],
                // Côté droit
                [5.8, 5, 8], [5.8, 5, 4], [5.8, 5, 0], [5.8, 5, -4], [5.8, 5, -8]
            ];

            const windowGeometry = new THREE.PlaneGeometry(3.5, 3.5);
            const windowMaterial = new THREE.MeshPhongMaterial({
                color: 0x87CEEB,
                transparent: true,
                opacity: 0.7,
                shininess: 200
            });

            windowPositions.forEach((pos, index) => {
                const window = new THREE.Mesh(windowGeometry, windowMaterial);
                window.position.set(pos[0], pos[1], pos[2]);
                window.rotation.y = index < 5 ? Math.PI / 2 : -Math.PI / 2;
                group.add(window);
            });

            // Fenêtre avant panoramique
            const frontWindowGeometry = new THREE.PlaneGeometry(8, 4);
            const frontWindow = new THREE.Mesh(frontWindowGeometry, windowMaterial);
            frontWindow.position.set(0, 6, 12.8);
            group.add(frontWindow);

            // Fenêtre arrière
            const rearWindow = new THREE.Mesh(frontWindowGeometry, windowMaterial);
            rearWindow.position.set(0, 6, -12.8);
            rearWindow.rotation.y = Math.PI;
            group.add(rearWindow);

            // Portes du bus
            const doorGeometry = new THREE.BoxGeometry(0.4, 6, 5);
            const doorMaterial = new THREE.MeshPhongMaterial({ color: 0x555555 });

            const doorPositions = [[-5.9, 3, 3], [5.9, 3, 3], [-5.9, 3, -3], [5.9, 3, -3]];
            doorPositions.forEach(pos => {
                const door = new THREE.Mesh(doorGeometry, doorMaterial);
                door.position.set(pos[0], pos[1], pos[2]);
                group.add(door);
            });

            // Phares avant LED réalistes
            const headlightGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.3, 16);
            const headlightMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFFFFF,
                emissive: 0x444444,
                shininess: 100
            });

            const headlightPositions = [[-4, 3, 13], [4, 3, 13]];
            headlightPositions.forEach(pos => {
                const headlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
                headlight.position.set(pos[0], pos[1], pos[2]);
                headlight.rotation.x = Math.PI / 2;
                group.add(headlight);
            });

            // Feux arrière LED
            const taillightGeometry = new THREE.BoxGeometry(2, 1.5, 0.4);
            const taillightMaterial = new THREE.MeshPhongMaterial({
                color: 0xFF0000,
                emissive: 0x330000,
                shininess: 100
            });

            const taillightPositions = [[-4, 3, -13], [4, 3, -13]];
            taillightPositions.forEach(pos => {
                const taillight = new THREE.Mesh(taillightGeometry, taillightMaterial);
                taillight.position.set(pos[0], pos[1], pos[2]);
                group.add(taillight);
            });

            // Numéro de ligne affiché
            const numberGeometry = new THREE.PlaneGeometry(4, 2);
            const numberMaterial = new THREE.MeshPhongMaterial({
                color: 0x000000,
                emissive: 0x002200
            });
            const numberDisplay = new THREE.Mesh(numberGeometry, numberMaterial);
            numberDisplay.position.set(0, 7, 13.2);
            group.add(numberDisplay);

            // Grille de protection avant
            const grilleGeometry = new THREE.BoxGeometry(8, 1.5, 0.3);
            const grilleMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const grille = new THREE.Mesh(grilleGeometry, grilleMaterial);
            grille.position.y = 2.5;
            grille.position.z = 13.2;
            group.add(grille);

            // Rétroviseurs
            const mirrorGeometry = new THREE.BoxGeometry(0.3, 0.3, 1);
            const mirrorMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });

            const mirrorPositions = [[-6.5, 7, 8], [6.5, 7, 8]];
            mirrorPositions.forEach(pos => {
                const mirror = new THREE.Mesh(mirrorGeometry, mirrorMaterial);
                mirror.position.set(pos[0], pos[1], pos[2]);
                group.add(mirror);
            });

            // Antenne radio
            const antennaGeometry = new THREE.CylinderGeometry(0.05, 0.05, 3, 8);
            const antennaMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
            antenna.position.set(0, 10, 0);
            group.add(antenna);

            // Climatisation sur le toit
            const acGeometry = new THREE.BoxGeometry(6, 1, 4);
            const acMaterial = new THREE.MeshPhongMaterial({ color: 0x999999 });
            const ac = new THREE.Mesh(acGeometry, acMaterial);
            ac.position.set(0, 9.5, 0);
            group.add(ac);
        }

        setupAI() {
            this.aiState = {
                target: null,
                lastDecision: 0,
                avoidanceVector: { x: 0, z: 0 },
                stopForLight: false,
                currentIntersection: null,
                pathFinding: {
                    waypoints: [],
                    currentWaypoint: 0,
                    stuckTimer: 0
                }
            };
        }

        update(deltaTime) {
            if (this.crashed) return;

            if (!this.isPlayer) {
                this.updateAI(deltaTime);
            } else {
                this.updatePlayerBus(deltaTime);
            }

            this.updatePhysics(deltaTime);
            this.mesh.position.set(this.position.x, 0, this.position.z);
            this.mesh.rotation.y = this.rotation;
            this.checkCollisions();
            this.updateVisualEffects();
            this.updateProgress();
        }

        updatePlayerBus(deltaTime) {
            if (this.busData) {
                this.busData.currentLat = this.position.x;
                this.busData.currentLng = this.position.z;
                updateRouteInfo();
            }
        }

        updateProgress() {
            if (this.busData && this.destination) {
                const startDistance = Math.sqrt(
                    Math.pow(this.destination.x - (this.busData.startLat || 0), 2) +
                    Math.pow(this.destination.z - (this.busData.startLng || 0), 2)
                );

                const currentDistance = Math.sqrt(
                    Math.pow(this.destination.x - this.position.x, 2) +
                    Math.pow(this.destination.z - this.position.z, 2)
                );

                if (this.totalDistance === 0) {
                    this.totalDistance = startDistance;
                }

                const progress = Math.max(0, Math.min(100, ((this.totalDistance - currentDistance) / this.totalDistance) * 100));
                gameState.busProgress[this.busData.id] = progress;

                if (currentDistance < 50 && progress >= 99) {
                    this.arriveAtDestination();
                }
            }
        }

        arriveAtDestination() {
            if (this.busData) {
                gameState.busProgress[this.busData.id] = 100;
                showNotification(`Bus ${this.busData.name} arrivé à destination!`, 'success');

                BackendAPI.updateBusStatus(this.busData.id, 'ARRIVE', this.destination);

                this.speed = 0;
                if (this.isAutoSimulation) {
                    setTimeout(() => {
                        this.remove();
                    }, 3000);
                }
            }
        }

        updateAI(deltaTime) {
            const obstacles = this.detectObstacles();
            this.handleTrafficLights();

            if (this.isAutoSimulation && this.destination) {
                this.navigateToDestination();
            }

            if (obstacles.length > 0) {
                this.avoidObstacles(obstacles);
            } else {
                this.normalDriving();
            }

            this.updatePathFinding();
        }

        navigateToDestination() {
            if (this.destination) {
                const dx = this.destination.x - this.position.x;
                const dz = this.destination.z - this.position.z;
                const targetAngle = Math.atan2(dx, dz);

                let angleDiff = targetAngle - this.rotation;
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                this.rotation += angleDiff * 0.02;
                this.targetSpeed = 25;
            }
        }

        detectObstacles() {
            const obstacles = [];
            const detectionRange = this.type === 'city_bus' ? 70 : 50;

            vehicles.forEach(vehicle => {
                if (vehicle === this) return;

                const distance = Math.sqrt(
                    Math.pow(vehicle.position.x - this.position.x, 2) +
                    Math.pow(vehicle.position.z - this.position.z, 2)
                );

                if (distance < detectionRange) {
                    const angle = Math.atan2(
                        vehicle.position.x - this.position.x,
                        vehicle.position.z - this.position.z
                    );
                    const angleDiff = Math.abs(angle - this.rotation);

                    if (angleDiff < Math.PI / 3) {
                        obstacles.push({
                            vehicle: vehicle,
                            distance: distance,
                            angle: angle
                        });
                    }
                }
            });

            return obstacles;
        }

        handleTrafficLights() {
            trafficLights.forEach(light => {
                const distance = Math.sqrt(
                    Math.pow(light.position.x - this.position.x, 2) +
                    Math.pow(light.position.z - this.position.z, 2)
                );

                if (distance < 50) {
                    const angle = Math.atan2(
                        light.position.x - this.position.x,
                        light.position.z - this.position.z
                    );
                    const angleDiff = Math.abs(angle - this.rotation);

                    if (angleDiff < Math.PI / 4 && light.currentState !== 'green') {
                        this.speed = Math.max(0, this.speed - 3);
                        this.aiState.stopForLight = true;
                    } else if (light.currentState === 'green') {
                        this.aiState.stopForLight = false;
                    }
                }
            });
        }

        avoidObstacles(obstacles) {
            let avoidanceX = 0, avoidanceZ = 0;
            let minDistance = Infinity;

            obstacles.forEach(obstacle => {
                const dx = this.position.x - obstacle.vehicle.position.x;
                const dz = this.position.z - obstacle.vehicle.position.z;
                const distance = obstacle.distance;

                if (distance < minDistance) {
                    minDistance = distance;
                }

                if (distance < 30) {
                    avoidanceX += dx / distance;
                    avoidanceZ += dz / distance;
                    this.speed = Math.max(0, this.speed - 2);
                }
            });

            if (minDistance < 20) {
                this.speed = Math.max(0, this.speed - 4);
            }

            this.rotation += (avoidanceX * 0.08) % (Math.PI * 2);

            if (this.speed < 5 && minDistance < 25) {
                this.aiState.pathFinding.stuckTimer += 1;
                if (this.aiState.pathFinding.stuckTimer > 120) {
                    this.rotation += (Math.random() - 0.5) * 0.5;
                    this.aiState.pathFinding.stuckTimer = 0;
                }
            }
        }

        normalDriving() {
            if (this.speed < this.targetSpeed && !this.aiState.stopForLight) {
                this.speed = Math.min(this.targetSpeed, this.speed + this.acceleration);
            } else if (this.speed > this.targetSpeed || this.aiState.stopForLight) {
                this.speed = Math.max(0, this.speed - this.acceleration);
            }

            if (Math.random() < 0.002) {
                this.rotation += (Math.random() - 0.5) * 0.2;
            }

            if (Math.random() < 0.001) {
                this.targetSpeed = Math.random() * this.maxSpeed;
            }
        }

        updatePathFinding() {
            if (Math.random() < 0.01) {
                const roadDirections = [0, Math.PI/2, Math.PI, 3*Math.PI/2];
                const closestDirection = roadDirections.reduce((prev, curr) =>
                    Math.abs(curr - this.rotation) < Math.abs(prev - this.rotation) ? curr : prev
                );

                if (Math.abs(closestDirection - this.rotation) > 0.1) {
                    this.rotation += (closestDirection - this.rotation) * 0.02;
                }
            }
        }

        updatePhysics(deltaTime) {
            this.position.x += Math.sin(this.rotation) * this.speed * deltaTime;
            this.position.z += Math.cos(this.rotation) * this.speed * deltaTime;

            const worldLimit = CONFIG.WORLD_SIZE / 2;
            if (Math.abs(this.position.x) > worldLimit) {
                this.position.x = Math.sign(this.position.x) * worldLimit;
                this.rotation = Math.PI - this.rotation;
            }
            if (Math.abs(this.position.z) > worldLimit) {
                this.position.z = Math.sign(this.position.z) * worldLimit;
                this.rotation = -this.rotation;
            }
        }

        updateVisualEffects() {
            if (this.mesh && this.mesh.children.length > 0) {
                const speedFactor = this.speed / this.maxSpeed;

                this.mesh.children.forEach(child => {
                    if (child.geometry && child.geometry.type === 'CylinderGeometry') {
                        child.rotation.x += speedFactor * 0.3;
                    }
                });

                this.lastSpeed = this.speed;
            }
        }

        checkCollisions() {
            vehicles.forEach(vehicle => {
                if (vehicle === this || vehicle.crashed) return;

                const distance = Math.sqrt(
                    Math.pow(vehicle.position.x - this.position.x, 2) +
                    Math.pow(vehicle.position.z - this.position.z, 2)
                );

                const minDistance = this.type === 'city_bus' || vehicle.type === 'city_bus' ? 15 : 10;

                if (distance < minDistance) {
                    this.handleCollision(vehicle);
                }
            });
        }

        handleCollision(otherVehicle) {
            if (this.crashed || otherVehicle.crashed) return;

            this.crashed = true;
            otherVehicle.crashed = true;

            this.speed = 0;
            otherVehicle.speed = 0;

            this.mesh.children.forEach(child => {
                if (child.material) {
                    child.material.color.setHex(0x444444);
                    child.material.transparent = true;
                    child.material.opacity = 0.7;
                }
            });

            otherVehicle.mesh.children.forEach(child => {
                if (child.material) {
                    child.material.color.setHex(0x444444);
                    child.material.transparent = true;
                    child.material.opacity = 0.7;
                }
            });

            this.createCollisionEffect();

            gameState.accidents++;
            showAccidentAlert();

            this.saveIncidentToDatabase(otherVehicle);

            setTimeout(() => {
                this.remove();
                otherVehicle.remove();
            }, 8000);
        }

        saveIncidentToDatabase(otherVehicle) {
            const incidentData = {
                incidentType: 'COLLISION',
                location: `Kinshasa (${Math.round(this.position.x)}, ${Math.round(this.position.z)})`,
                dateTime: new Date().toISOString(),
                summary: `Collision entre véhicules - ${this.type} et ${otherVehicle.type}`,
                status: 'REPORTED',
                severity: 'HIGH',
                busId: this.busData ? this.busData.id : null,
                additionalDetails: {
                    vehicle1Type: this.type,
                    vehicle2Type: otherVehicle.type,
                    speed1: Math.round(this.speed),
                    speed2: Math.round(otherVehicle.speed),
                    weatherConditions: 'Clear',
                    roadConditions: 'Good'
                }
            };

            BackendAPI.saveIncident(incidentData);
        }

        createCollisionEffect() {
            const particleCount = 25;
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.3, 6, 6);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFF6600,
                    transparent: true,
                    opacity: 0.8
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);

                particle.position.set(
                    this.position.x + (Math.random() - 0.5) * 15,
                    2 + Math.random() * 8,
                    this.position.z + (Math.random() - 0.5) * 15
                );

                scene.add(particle);

                const animateParticle = () => {
                    particle.position.y += 0.2;
                    particle.material.opacity -= 0.02;

                    if (particle.material.opacity <= 0) {
                        scene.remove(particle);
                    } else {
                        requestAnimationFrame(animateParticle);
                    }
                };

                setTimeout(animateParticle, i * 30);
            }
        }

        remove() {
            scene.remove(this.mesh);
            const index = vehicles.indexOf(this);
            if (index > -1) {
                vehicles.splice(index, 1);
            }

            const simIndex = simulationBuses.indexOf(this);
            if (simIndex > -1) {
                simulationBuses.splice(simIndex, 1);
            }
        }
    }

    // Classe pour les feux de circulation améliorés
    class TrafficLight {
        constructor(x, z) {
            this.position = { x, z };
            this.currentState = 'red';
            this.timer = 0;
            this.states = ['red', 'yellow', 'green'];
            this.stateIndex = 0;
            this.interval = CONFIG.TRAFFIC_LIGHT_INTERVAL + (Math.random() - 0.5) * 3000;

            this.createMesh();
        }

        createMesh() {
            const group = new THREE.Group();

            const poleGeometry = new THREE.CylinderGeometry(0.4, 0.4, 18, 12);
            const poleMaterial = new THREE.MeshPhongMaterial({
                color: 0x555555,
                shininess: 50
            });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 9;
            pole.castShadow = true;
            group.add(pole);

            const boxGeometry = new THREE.BoxGeometry(3, 10, 2);
            const boxMaterial = new THREE.MeshPhongMaterial({
                color: 0x222222,
                shininess: 100
            });
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            box.position.y = 15;
            box.castShadow = true;
            group.add(box);

            const hoodGeometry = new THREE.BoxGeometry(3.5, 0.8, 2.5);
            const hoodMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const hood = new THREE.Mesh(hoodGeometry, hoodMaterial);
            hood.position.y = 20.5;
            group.add(hood);

            const lightGeometry = new THREE.CircleGeometry(0.8, 20);

            this.redLight = new THREE.Mesh(lightGeometry,
                new THREE.MeshPhongMaterial({
                    color: 0x330000,
                    emissive: 0x110000
                }));
            this.redLight.position.set(0, 18, 1.1);
            group.add(this.redLight);

            this.yellowLight = new THREE.Mesh(lightGeometry,
                new THREE.MeshPhongMaterial({
                    color: 0x333300,
                    emissive: 0x111100
                }));
            this.yellowLight.position.set(0, 15, 1.1);
            group.add(this.yellowLight);

            this.greenLight = new THREE.Mesh(lightGeometry,
                new THREE.MeshPhongMaterial({
                    color: 0x003300,
                    emissive: 0x001100
                }));
            this.greenLight.position.set(0, 12, 1.1);
            group.add(this.greenLight);

            this.mesh = group;
            this.mesh.position.set(this.position.x, 0, this.position.z);
            scene.add(this.mesh);

            this.updateLights();
        }

        update(deltaTime) {
            this.timer += deltaTime * 1000;

            if (this.timer >= this.interval) {
                this.timer = 0;
                this.stateIndex = (this.stateIndex + 1) % this.states.length;
                this.currentState = this.states[this.stateIndex];
                this.updateLights();
            }
        }

        updateLights() {
            this.redLight.material.color.setHex(0x330000);
            this.redLight.material.emissive.setHex(0x110000);
            this.yellowLight.material.color.setHex(0x333300);
            this.yellowLight.material.emissive.setHex(0x111100);
            this.greenLight.material.color.setHex(0x003300);
            this.greenLight.material.emissive.setHex(0x001100);

            switch (this.currentState) {
                case 'red':
                    this.redLight.material.color.setHex(0xFF0000);
                    this.redLight.material.emissive.setHex(0x440000);
                    break;
                case 'yellow':
                    this.yellowLight.material.color.setHex(0xFFFF00);
                    this.yellowLight.material.emissive.setHex(0x444400);
                    break;
                case 'green':
                    this.greenLight.material.color.setHex(0x00FF00);
                    this.greenLight.material.emissive.setHex(0x004400);
                    break;
            }
        }
    }

    // Initialisation du jeu
    function init() {
        console.log('Initialisation du simulateur IMAS...');

        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87CEEB, 300, 2000);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
        camera.position.set(0, 80, 150);

        renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('gameCanvas'),
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setClearColor(0x87CEEB, 1);

        setupLighting();
        createWorld();
        createRoads();
        createBuildings();
        createTrafficLights();
        createAIVehicles();
        setupEventListeners();

        // Charger les données depuis la base de données
        Promise.all([
            BackendAPI.loadBuses(),
            BackendAPI.loadRoutes()
        ]).then(([buses, routes]) => {
            console.log('Données chargées avec succès');
            routeDatabase = routes;
            showNotification('Système IMAS initialisé avec succès', 'success');
        }).catch(error => {
            console.error('Erreur lors du chargement des données:', error);
            showNotification('Erreur lors du chargement des données', 'error');
        });

        animate();
        document.getElementById('loading').style.display = 'none';
    }

    function setupLighting() {
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 0.8);
        directionalLight.position.set(1500, 1500, 1500);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 4096;
        directionalLight.shadow.mapSize.height = 4096;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 4000;
        directionalLight.shadow.camera.left = -1500;
        directionalLight.shadow.camera.right = 1500;
        directionalLight.shadow.camera.top = 1500;
        directionalLight.shadow.camera.bottom = -1500;
        scene.add(directionalLight);

        const goldenLight = new THREE.DirectionalLight(0xFFD700, 0.3);
        goldenLight.position.set(-800, 500, -800);
        scene.add(goldenLight);

        const nightLight = new THREE.DirectionalLight(0x4444FF, 0.1);
        nightLight.position.set(0, 300, 0);
        scene.add(nightLight);
    }

    function createWorld() {
        const groundGeometry = new THREE.PlaneGeometry(CONFIG.WORLD_SIZE, CONFIG.WORLD_SIZE);
        const groundMaterial = new THREE.MeshLambertMaterial({
            color: 0x228B22,
            shininess: 0
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        const skyGeometry = new THREE.SphereGeometry(CONFIG.WORLD_SIZE * 0.9, 32, 32);
        const skyMaterial = new THREE.MeshBasicMaterial({
            color: 0x87CEEB,
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        createClouds();
        createTrees();
    }

    function createClouds() {
        const cloudGeometry = new THREE.SphereGeometry(30, 12, 12);
        const cloudMaterial = new THREE.MeshLambertMaterial({
            color: 0xFFFFFF,
            transparent: true,
            opacity: 0.8
        });

        for (let i = 0; i < 40; i++) {
            const cloudGroup = new THREE.Group();

            for (let j = 0; j < 4 + Math.random() * 4; j++) {
                const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                cloud.position.set(
                    (Math.random() - 0.5) * 60,
                    Math.random() * 25,
                    (Math.random() - 0.5) * 60
                );
                cloud.scale.set(
                    0.6 + Math.random() * 1.8,
                    0.4 + Math.random() * 0.8,
                    0.6 + Math.random() * 1.8
                );
                cloudGroup.add(cloud);
            }

            cloudGroup.position.set(
                (Math.random() - 0.5) * CONFIG.WORLD_SIZE * 0.8,
                180 + Math.random() * 120,
                (Math.random() - 0.5) * CONFIG.WORLD_SIZE * 0.8
            );

            scene.add(cloudGroup);
        }
    }

    function createTrees() {
        for (let i = 0; i < 150; i++) {
            const treeGroup = new THREE.Group();

            const trunkGeometry = new THREE.CylinderGeometry(1.2, 1.8, 10, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 5;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            const foliageGeometry = new THREE.SphereGeometry(5 + Math.random() * 3, 8, 8);
            const foliageMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.y = 12;
            foliage.castShadow = true;
            treeGroup.add(foliage);

            let x, z;
            do {
                x = (Math.random() - 0.5) * CONFIG.WORLD_SIZE * 0.9;
                z = (Math.random() - 0.5) * CONFIG.WORLD_SIZE * 0.9;
            } while (Math.abs(x) % 200 < 70 || Math.abs(z) % 200 < 70);

            treeGroup.position.set(x, 0, z);
            scene.add(treeGroup);
        }
    }

    function createRoads() {
        const roadMaterial = new THREE.MeshLambertMaterial({
            color: 0x333333,
            shininess: 10
        });

        const roadSpacing = 200;
        const roadCount = Math.floor(CONFIG.WORLD_SIZE / roadSpacing);

        for (let i = -roadCount/2; i <= roadCount/2; i++) {
            const roadGeometry = new THREE.PlaneGeometry(CONFIG.WORLD_SIZE, CONFIG.ROAD_WIDTH);
            const road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = -Math.PI / 2;
            road.position.set(0, 0.1, i * roadSpacing);
            road.receiveShadow = true;
            scene.add(road);
            roads.push(road);

            createRoadMarkings(0, i * roadSpacing, CONFIG.WORLD_SIZE, true);

            const roadGeometry2 = new THREE.PlaneGeometry(CONFIG.ROAD_WIDTH, CONFIG.WORLD_SIZE);
            const road2 = new THREE.Mesh(roadGeometry2, roadMaterial);
            road2.rotation.x = -Math.PI / 2;
            road2.position.set(i * roadSpacing, 0.1, 0);
            road2.receiveShadow = true;
            scene.add(road2);
            roads.push(road2);

            createRoadMarkings(i * roadSpacing, 0, CONFIG.WORLD_SIZE, false);
        }
    }

    function createRoadMarkings(x, z, length, isHorizontal) {
        const lineMaterial = new THREE.MeshLambertMaterial({
            color: 0xFFFFFF,
            emissive: 0x111111
        });

        const centralLineGeometry = new THREE.PlaneGeometry(
            isHorizontal ? length : 2,
            isHorizontal ? 2 : length
        );
        const centralLine = new THREE.Mesh(centralLineGeometry, lineMaterial);
        centralLine.rotation.x = -Math.PI / 2;
        centralLine.position.set(x, 0.15, z);
        scene.add(centralLine);

        const dashLength = 18;
        const dashGap = 30;
        const totalLength = length;
        const dashCount = Math.floor(totalLength / (dashLength + dashGap));

        for (let i = 0; i < dashCount; i++) {
            const dash = new THREE.Mesh(
                new THREE.PlaneGeometry(
                    isHorizontal ? dashLength : 1.5,
                    isHorizontal ? 1.5 : dashLength
                ),
                lineMaterial
            );
            dash.rotation.x = -Math.PI / 2;

            const offset = (i - dashCount/2) * (dashLength + dashGap);

            if (isHorizontal) {
                dash.position.set(x + offset, 0.15, z + CONFIG.ROAD_WIDTH/3);
                const dash2 = dash.clone();
                dash2.position.set(x + offset, 0.15, z - CONFIG.ROAD_WIDTH/3);
                scene.add(dash2);
            } else {
                dash.position.set(x + CONFIG.ROAD_WIDTH/3, 0.15, z + offset);
                const dash2 = dash.clone();
                dash2.position.set(x - CONFIG.ROAD_WIDTH/3, 0.15, z + offset);
                scene.add(dash2);
            }
            scene.add(dash);
        }
    }

    function createBuildings() {
        const buildingTypes = [
            { width: 30, height: 40, depth: 30, color: 0x8B4513, type: 'residential' },
            { width: 35, height: 70, depth: 35, color: 0x696969, type: 'office' },
            { width: 45, height: 90, depth: 45, color: 0x2F4F4F, type: 'skyscraper' },
            { width: 40, height: 30, depth: 40, color: 0x8B0000, type: 'commercial' },
            { width: 25, height: 120, depth: 25, color: 0x191970, type: 'tower' }
        ];

        const buildingSpacing = 100;
        const buildingCount = Math.floor(CONFIG.WORLD_SIZE / buildingSpacing);

        for (let i = -buildingCount/2; i <= buildingCount/2; i++) {
            for (let j = -buildingCount/2; j <= buildingCount/2; j++) {
                if (Math.abs(i * buildingSpacing) % 200 < 70 ||
                    Math.abs(j * buildingSpacing) % 200 < 70) {
                    continue;
                }

                if (Math.random() > 0.5) continue;

                const buildingType = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                const building = createBuilding(
                    i * buildingSpacing + (Math.random() - 0.5) * 50,
                    j * buildingSpacing + (Math.random() - 0.5) * 50,
                    buildingType
                );
                buildings.push(building);
            }
        }
    }

    function createBuilding(x, z, type) {
        const group = new THREE.Group();

        const buildingGeometry = new THREE.BoxGeometry(type.width, type.height, type.depth);
        const buildingMaterial = new THREE.MeshPhongMaterial({
            color: type.color,
            shininess: 50
        });
        const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
        building.position.y = type.height / 2;
        building.castShadow = true;
        building.receiveShadow = true;
        group.add(building);

        const windowSize = 3;
        const windowSpacing = 6;
        const windowRows = Math.floor(type.height / windowSpacing);
        const windowCols = Math.floor(type.width / windowSpacing);

        for (let row = 1; row < windowRows; row++) {
            for (let col = 1; col < windowCols; col++) {
                if (Math.random() > 0.7) continue;

                const windowGeometry = new THREE.PlaneGeometry(windowSize, windowSize);
                const isLit = Math.random() > 0.3;
                const windowMaterial = new THREE.MeshPhongMaterial({
                    color: isLit ? 0xFFFF99 : 0x333333,
                    emissive: isLit ? 0x221100 : 0x000000,
                    transparent: true,
                    opacity: 0.9
                });

                const faces = [
                    { x: type.width/2 + 0.1, z: 0, rotY: 0 },
                    { x: -type.width/2 - 0.1, z: 0, rotY: Math.PI },
                    { x: 0, z: type.depth/2 + 0.1, rotY: -Math.PI/2 },
                    { x: 0, z: -type.depth/2 - 0.1, rotY: Math.PI/2 }
                ];

                faces.forEach(face => {
                    const window = new THREE.Mesh(windowGeometry, windowMaterial);
                    window.position.set(
                        face.x + (col - windowCols/2) * windowSpacing,
                        (row - windowRows/2) * windowSpacing + type.height/2,
                        face.z
                    );
                    window.rotation.y = face.rotY;
                    group.add(window);
                });
            }
        }

        const roofGeometry = new THREE.BoxGeometry(type.width + 3, 4, type.depth + 3);
        const roofMaterial = new THREE.MeshPhongMaterial({
            color: 0x654321,
            shininess: 20
        });
        const roof = new THREE.Mesh(roofGeometry, roofMaterial);
        roof.position.y = type.height + 2;
        roof.castShadow = true;
        group.add(roof);

        if (Math.random() > 0.6) {
            const antennaGeometry = new THREE.CylinderGeometry(0.3, 0.3, 8, 8);
            const antennaMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
            const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
            antenna.position.y = type.height + 8;
            antenna.castShadow = true;
            group.add(antenna);
        }

        group.position.set(x, 0, z);
        scene.add(group);

        return group;
    }

    function createTrafficLights() {
        const lightSpacing = 200;
        const lightCount = Math.floor(CONFIG.WORLD_SIZE / lightSpacing);

        for (let i = -lightCount/2; i <= lightCount/2; i++) {
            for (let j = -lightCount/2; j <= lightCount/2; j++) {
                if (i === 0 && j === 0) continue;

                const light = new TrafficLight(i * lightSpacing, j * lightSpacing);
                trafficLights.push(light);
            }
        }
    }

    function createAIVehicles() {
        const vehicleTypes = ['sports_car', 'city_bus', 'sports_car', 'sports_car'];

        for (let i = 0; i < CONFIG.VEHICLE_COUNT; i++) {
            const x = (Math.random() - 0.5) * CONFIG.WORLD_SIZE * 0.6;
            const z = (Math.random() - 0.5) * CONFIG.WORLD_SIZE * 0.6;
            const type = vehicleTypes[Math.floor(Math.random() * vehicleTypes.length)];

            const vehicle = new Vehicle(x, z, type);
            vehicles.push(vehicle);
        }
    }

    function setupEventListeners() {
        document.addEventListener('keydown', (event) => {
            keys[event.code] = true;

            switch(event.code) {
                case 'KeyC':
                    changeCameraMode();
                    break;
                case 'KeyR':
                    resetGame();
                    break;
                case 'KeyP':
                    togglePause();
                    break;
                case 'KeyM':
                    openBusModal();
                    break;
                case 'KeyA':
                    toggleAutoSimulation();
                    break;
                case 'Tab':
                    event.preventDefault();
                    toggleMap();
                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            keys[event.code] = false;
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Event listeners pour les boutons
        document.getElementById('toggleUI').addEventListener('click', toggleUI);

        // Fermer les modals en cliquant à l'extérieur
        window.addEventListener('click', (event) => {
            if (event.target.classList.contains('modal')) {
                event.target.style.display = 'none';
            }
        });
    }

    function handlePlayerInput() {
        if (!playerCar || playerCar.crashed) return;

        const acceleration = 2.0;
        const steering = 0.03;
        const friction = 0.95;

        if (keys['KeyW'] || keys['ArrowUp']) {
            playerCar.speed = Math.min(playerCar.maxSpeed, playerCar.speed + acceleration);
        }

        if (keys['KeyS'] || keys['ArrowDown']) {
            playerCar.speed = Math.max(-playerCar.maxSpeed/2, playerCar.speed - acceleration);
        }

        if (keys['Space']) {
            playerCar.speed *= 0.8;
        }

        if (keys['KeyA'] || keys['ArrowLeft']) {
            playerCar.rotation -= steering * Math.abs(playerCar.speed) / playerCar.maxSpeed;
        }
        if (keys['KeyD'] || keys['ArrowRight']) {
            playerCar.rotation += steering * Math.abs(playerCar.speed) / playerCar.maxSpeed;
        }

        if (!keys['KeyW'] && !keys['ArrowUp'] && !keys['KeyS'] && !keys['ArrowDown']) {
            playerCar.speed *= friction;
        }

        playerCar.rotation = playerCar.rotation % (Math.PI * 2);
    }

    function changeCameraMode() {
        cameraMode = (cameraMode + 1) % 3;

        const modes = ['Troisième Personne', 'Première Personne', 'Vue d\'Oiseau'];
        document.getElementById('cameraMode').textContent = modes[cameraMode];
    }

    function updateCamera() {
        if (!playerCar) {
            camera.position.set(0, 300, 0);
            camera.lookAt(0, 0, 0);
            return;
        }

        const playerPos = playerCar.position;
        const playerRot = playerCar.rotation;

        switch(cameraMode) {
            case 0: // Troisième personne
                camera.position.x = playerPos.x - Math.sin(playerRot) * 50 / zoomLevel;
                camera.position.y = 20 * zoomLevel;
                camera.position.z = playerPos.z - Math.cos(playerRot) * 50 / zoomLevel;
                camera.lookAt(playerPos.x, 5, playerPos.z);
                break;

            case 1: // Première personne
                camera.position.x = playerPos.x + Math.sin(playerRot) * 5;
                camera.position.y = 8;
                camera.position.z = playerPos.z + Math.cos(playerRot) * 5;
                camera.lookAt(
                    playerPos.x + Math.sin(playerRot) * 50,
                    5,
                    playerPos.z + Math.cos(playerRot) * 50
                );
                break;

            case 2: // Vue d'oiseau
                camera.position.x = playerPos.x;
                camera.position.y = 200 * zoomLevel;
                camera.position.z = playerPos.z;
                camera.lookAt(playerPos.x, 0, playerPos.z);
                break;
        }
    }

    function updateUI() {
        const speed = playerCar ? Math.round(Math.abs(playerCar.speed)) : 0;
        document.getElementById('speed').textContent = speed;
        document.getElementById('speedDisplay').textContent = speed;
        document.getElementById('accidents').textContent = gameState.accidents;
        document.getElementById('vehicleCount').textContent = vehicles.length;
        document.getElementById('fps').textContent = Math.round(1000 / (performance.now() - lastTime));
    }

    function showAccidentAlert() {
        const alert = document.getElementById('accidentAlert');
        alert.style.display = 'block';

        setTimeout(() => {
            alert.style.display = 'none';
        }, 5000);
    }

    function resetGame() {
        if (playerCar) {
            playerCar.position.x = 0;
            playerCar.position.z = 0;
            playerCar.rotation = 0;
            playerCar.speed = 0;
            playerCar.crashed = false;

            if (playerCar.mesh.children[0]) {
                playerCar.mesh.children[0].material.color.setHex(0x00FF00);
                playerCar.mesh.children[0].material.transparent = false;
                playerCar.mesh.children[0].material.opacity = 1;
            }
        }

        gameState.accidents = 0;
        gameState.speed = 0;
        gameState.busProgress = {};

        showNotification('Simulation redémarrée', 'info');
    }

    function togglePause() {
        gameState.isPaused = !gameState.isPaused;
        showNotification(gameState.isPaused ? 'Simulation en pause' : 'Simulation reprise', 'info');
    }

    function animate() {
        requestAnimationFrame(animate);

        const currentTime = performance.now();
        const deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;

        if (gameState.isPaused) return;

        handlePlayerInput();

        vehicles.forEach(vehicle => {
            vehicle.update(CONFIG.PHYSICS_TIMESTEP);
        });

        trafficLights.forEach(light => {
            light.update(CONFIG.PHYSICS_TIMESTEP);
        });

        updateCamera();
        updateUI();

        renderer.render(scene, camera);
    }

    // Démarrage du jeu
    window.addEventListener('load', init);
</script>
<script src="js/singleWindowValidator.js"></script>
</body>
</html>